* 函數呼叫: 其實就是執行函數，在 JS 裡面，我們用 “()” 來做這件事情。
* 執行堆: 每一次你在 JS 裡執行函數，就會創造一個新的執行環境([2-9 全域環境與全域物件](2-9%20全域環境與全域物件.md)), 然後被堆進執行堆中的最上方，所以一個新的執行環境被創造就像全域執行環境一樣，他會有自己的記憶體空間給變數和函數，經過創造階段然後逐行執行程式。
---
在函數中剩下的程式碼順序也不會影響執行先後, 那他會怎麼執行呢?     
> a() 會先執行，所以他會先進入執行堆，然後會變成目前執行的程式，就是 a() 產生的執行環境，所以接著會呼叫 b()，接著 b 進入執行堆，然後再執行 b() 產生的執行環境，當執行完之後，b 會離開執行堆，回到 a 執行堆執行剩下沒執行到的地方(var c)，然後 a 也離開執行堆，最後執行全域執行環境(global execution context)。        

所以會是: a() —> b() —> var d —> var c —> var d (global 的那個)
![](./photo/Pasted%20image%2020221029165715.png)

tag: #JS #FunctionInvocation #ExecutionStack
